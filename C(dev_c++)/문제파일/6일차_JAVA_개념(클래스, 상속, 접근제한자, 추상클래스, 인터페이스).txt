day06_java

1. 클래스, 인스턴스, 메소드
클래스
	표현하고자 하는 대상의 공통 속성을 한 군데에 정의해 놓은 것, 객체의 속성을 정의한 것
	객체의 속성  필드, 메소드, 생성자가 있음
	필드(전역변수)는 멤버 변수라고도 함
	필드는 클래스 내부 전역에서 사용 가능한 전역 변수
	메소드와 생성자에서 정의된 변수는 지역변수

인스턴스
	클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함

+) 클래스와 인스턴스 비유
	클래스는 붕어빵을 만들어내는 틀이라고 할 수 있으며, 인스턴스는 붕어빵 틀에 의해 만들어진 붕어빵

메소드
	메소드는 어떠한 작업을 수행하는 코드를 하나로 묶어 놓은 것
	메소드 내의 변수는 지역변수로, 메소드 내부에서만 사용가능함
	메소드명은 동사로하되 캐멀케이스를 사용한다.
		메소드 
		반환타입 메소드이름 (타입 변수명,타입 변수명, ...){ 
			수행되어야 할 코드
		}

2. 생성자
생성자
	인스턴스가 생성될 때 사용되는 인스턴스 초기화 메소드
	즉 new 와 같은 키워드로 해당 클래스의 인스턴스가 새로 생성될 때, 자동으로 호출되는 메소드
	대표적으로 인스턴스의 변수를 초기화하는 용도의 생성자가 있음
	생성자의 이름은 클래스 명과 같아야하며, 리턴값이 없다는 특징
	클래스를 선언할 때 따로 선언하지 않아도 매개변수와 내용이 없는 디폴트 생성자가 생성됨

+)팁 alt + insert를 누르면 자동으로 생성자, getter, setter, toString등의 코드를 작성할 수 있다.

	클래스이름 (타입 변수명, 타입 변수명, ...){
		인스턴스 생성 될 때에 수행해야할 코드
		변수의 초기화 코드
	}

3. 상속
상속
	기존의 클래스를 재사용하는 방식 중의 하나로 한 번 작성한 코드가 재사용이 필요하다면, 
	변경사항만 코드로 작성하므로 상대적으로 적은 양의 코드를 작성가능함
	코드를 재사용하면 코드와 클래스가 많아질수록 관리가 용이함

	extends 키워드를 사용함(하나의 클래스만 상속 가능)

	상속을 하게되면 자식 클래스에서는
		1. 부모 클래스로에서 정의된 필드와 메소드를 물려 받는다.
		2. 새로운 필드와 메소드를 추가할 수 있다.
		3. 부모 클래스스에서 물려받은 메소드를 수정할 수 있다.

super, super() 메소드
	부모 클래스로부터 상속받은 필드나 메소드나 생성자를 자식 클래스에서 참조하여 사용하고 싶을 때 사용하는 키워드

this, this() 메소드와 차이점
	this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면 super() 메소드는 부모 클래스의 생성자를 호출할 때 사용됨
	super()의 매개변수 자리에는 부모 클래스 생성자의 매개변수와 동일하게 들어가야 함
	예를 들어 부모 클래스에 기본생성자가 없는 경우 자식 클래스에서 super(); 만 선언하면 컴파일 에러가 발생함	(매개변수 자리가 빈 기본 생성자가 부모 클래스에 정의되어 있지 않기 때문)

+) 쉽게 생각하면 this는 현재 scope의 클래스를 지칭한다.

4. 오버로딩과 오버라이딩
오버로딩
	한 클래스 내에 동일한 이름의 메소드를 여러개 정의하는 것
	메소드 간 이름이 동일해야하며 매개변수의 개수 및 타입이 전부 동일하다면 오버로딩이 아님

오버라이딩
	부모 클래스로부터 상속받은 메소드의 내용을 변경하는 것
	상속받은 메소드를 그대로 사용하기도 하지만, 필요에 의해 변경해야할 경우 오버라이딩
	부모 클래스의 메소드와 이름, 매개변수, 반환타입이 동일해야한다.

즉 오버로딩은 기존에 없는 새로운 메소드를 정의하는 것이며 오버라이딩은 상속받은 메소드의 내용을 변경하는 것이다.

5. 접근 제어자 (access modifier)
	접근 제어자는 멤버 변수/함수 혹은 클래스에 사용되며 외부에서의 접근을 제한하는 역할
	private : 같은 클래스 내에서만 접근이 가능합니다
	default(nothing) : 같은 패키지 내에서만 접근이 가능합니다.
	protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능합니다.
	public : 접근 제한이 전혀 없습니다.

	접근 제어자로 제어하는 것을 캡슐화 라고 한다. (encapsulation)
	객체지향 프로그래밍이란 객체들 간의 상호작용을 코드로 표현하는 것
	이때 객체들간의 관계에 따라서 접근 할 수 있는 것과 아닌 것, 권한을 구분할 필요가 생김
	클래스 내부에 선언된 데이터의 부적절한 사용으로부터 보호하기 위해서 사용하며 캡슐화(encapsulation)라고함
	접근 제어자는 캡슐화가 가능할 수 있도록 돕는 도구

6. 추상 클래스
추상클래스
	추상클래스는 추상메소드를 선언할 수 있는 클래스를 의미
	추상클래스는 클래스와는 다르게 상속받는 클래스 없이 그 자체로 인스턴스를 생성할 수는 없음
	추상메소드는 설계만 되어있으며 수행되는 코드에 대해서는 작성이 안된 메소드
	미완성으로 남겨두는 이유는 상속받는 클래스 마다 반드시 동작이 달라지는 경우에 상속받는 클래스 작성자가 반드시 작성하도록하기 위함입니다. (자식 클래스에서 오버라이딩하여 작성됨)

	추상 메소드 형식 👉 abstract 리턴타입 메소드이름();

7. 인터페이스
인터페이스
	객체의 특정 행동의 특징을 정의하는 간단한 문법
	인터페이스는 함수의 특징(method signature)인 접근제어자, 리턴타입, 메소드 이름만을 정의함
	함수의 내용은 없으며 인터페이스를 구현하는 클래스는 인터페이스에 존재하는 함수의 내용({} 중괄호 안의 내용)을 반드시 구현해야함

	인터페이스 형식 👉 interface 인터페이스명{ public abstract void 추상메서드명(); } → 인터페이스의 메소드는 추상메소드, static메소드, default 메소드 모두 허용됩니다. (JDK 1.8부터)

+) 추상 클래스와 인터페이스의 차이점
인터페이스
	인터페이스의 모든 메서드는 추상메서드이다.
	구현하려는 객체의 동작의 명세
	다중 상속 가능
	implements를 이용하여 구현
	메소드 시그니처(이름, 파라미터, 리턴 타입)에 대한 선언만 가능
	같은 이름의 메서드가 클래스에 따라 다르게 동작하도록 구현되는 것을 말하는 다형성을 지님
	인터페이스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용

추상클래스
	클래스를 상속받아 이용 및 확장을 위함
	다중 상속 불가능 , 단일 상속
	extends를 이용하여 구현
	추상메소드에 대한 구현 가능
	추상 클래스의 기능을 재사용, 확장한다는 측면에서 상속성을 지님
	추상클래스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우

추상클래스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우

인터페이스 사용 시기 : 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용

예제 코드 (복습용): https://github.com/Kim-HJ1986/Java/tree/master/src/main/java/interfaceExtendsPrac


참고: https://myjamong.tistory.com/150